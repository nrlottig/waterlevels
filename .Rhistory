df <- K+1
Sigma.B[1:K,1:K] <- inverse(Tau.B[,])
for (k in 1:K){
for (k.prime in 1:K){
rho.B[k,k.prime] <- Sigma.B[k,k.prime]/sqrt(Sigma.B[k,k]*Sigma.B[k.prime,k.prime])
}
sigma.B[k] <- sqrt(Sigma.B[k,k])
}
}
",fill=TRUE)
sink()
# Set up the parameters before run the model
# Number of parameters
K = 2
W <- diag(K)
dat <- dat %>% left_join(lake_params) %>%
mutate(residual_val = deltaS_mmd -(PE_mmd*slope + intercept))
data = list(y =dat$residual_val, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
x = dat$uniform_stage, K = K, W = W)
dat <- dt %>% dplyr::select(WiscID,WBIC,Date1,DeltaDate,Stage1_mm,Stage2_mm,DeltaWaterLevel_mm,
Precip_mm,Evap_mm) %>% drop_na() %>% arrange(WiscID,Date1) %>%
mutate(PE_mmd = (Precip_mm+Evap_mm)/DeltaDate) %>%
mutate(deltaS_mmd=DeltaWaterLevel_mm/DeltaDate) %>%
mutate(missing = PE_mmd - deltaS_mmd) %>%
filter(missing < 5) %>%
filter(missing > -5)
dat_stage <- dat %>% dplyr:::select(WiscID,Stage1_mm) %>%
group_by(WiscID) %>%
summarise(min_stage = min(Stage1_mm))
dat <- dat %>% left_join(dat_stage) %>%
mutate (uniform_stage = (Stage1_mm-min_stage)+98500)
#Filter the data so that we have at least 5 obs for each lake
(num.rec = table(dat$WBIC))
keep.rec = as.numeric(names((num.rec[which(num.rec>=10)])))
dat = dat[which(dat$WBIC %in% keep.rec),] %>% arrange(WBIC,Date1)
length(unique(dat$WBIC))
# Reassign a WiscID to all lakes
# This is not the WiscID used in the big dataset!!!
# Because the jags methods requires a consecutive ID list starting from 1
allLakeList = unique(dat$WBIC)
dat$BHMID = NA
for (i in 1:length(allLakeList)) {
dat$BHMID[dat$WBIC %in% allLakeList[i]] = i
}
dat
#Residual Model
lake_params <- data.frame(WBIC = allLakeList, intercept=BugsOut[1:J,1],slope=BugsOut[(J+1):(J*2),1])
dat <- dat %>% left_join(lake_params) %>%
mutate(residual_val = deltaS_mmd -(PE_mmd*slope + intercept))
plot(dat$uniform_stage,dat$residual_val)
# Set up the parameters before run the model
# Number of parameters
K = 2
W <- diag(K)
# Number of lakes
J = length(unique(dat$BHMID))
# Load data raw water level data
dat = as.data.frame(dat)
data = list(y =dat$residual_val, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
x = dat$uniform_stage, K = K, W = W)
# Initial values
r <- cor(data$x,data$y)
inits <- function (){
list (BB=array(c(rep(rnorm(1,0,1),J),rep(rnorm(1,0,1),J)), c(J,K)),
mu.a=rnorm(1,0,1),mu.b=rnorm(1,0,1),
sigma.y=runif(1,0,10),
Tau.B=rwish(K+1,diag(K))	 )
}
params1 <- c("BB","mu.a","mu.b", "sigma.y","sigma.B","rho.B")
# Parameters monitored
# mu.alpha: global alpha
# mu.beta: global beta
# BB: local alphas and betas
# sigma: local error term
# sigma.a: variances of alpha
# sigma.b: variances of beta
# rho: covarainces of alpha and beta
#
# MCMC settings
ni <- 7000
nb <- 2000
nc <- 5
nt <- 1
nadp <- 10000
# Run the model
out2 <- jags(data, inits, params1, "Model.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb,n.adapt = nadp,parallel = TRUE)
BugsOut2 <- out2$summary
BugsOut2
BugsOut2[99:100,]
scale?
?scale
data = list(y =dat$residual_val, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
x = scale(dat$uniform_stage,scale = FALSE), K = K, W = W)
# Run the model
out2 <- jags(data, inits, params1, "Model.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb,n.adapt = nadp,parallel = TRUE)
(BugsOut2 <- out2$summary)[1:nrow(BugsOut2)]
(BugsOut2 <- out2$summary)[1:nrow(BugsOut2),]
BugsOut2[99:100,]
library(tidyverse)
library(lubridate)
library(foreach)
library(doParallel)
library(iterators)
registerDoParallel(cores = 7)
# #limit the evap and precip data to the 50 lakes we have GW recharge estimates
# evap_daily <- read_csv("big_data/evap_daily.csv",
#                        col_types = cols(X1 = col_skip())) %>%
#   distinct(WBIC, Date,.keep_all = TRUE) %>% right_join(Gnet_slopes)
# precip_daily <- read_csv("big_data/precip_daily.csv",
#                          col_types = cols(X1 = col_skip())) %>%
#   distinct(WBIC, Date,.keep_all = TRUE) %>% right_join(Gnet_slopes)
#
# dat <- evap_daily %>% full_join(precip_daily)
# write_tsv(dat,"big_data/gnet_met_data.csv")
gnet_met_data <- read_delim("big_data/gnet_met_data.csv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gnet_mu_sims <- read_csv("data/gnet_mu_sims.csv")
lakes = unique(gnet_met_data$WBIC)
for(i in 1:length(lakes)) {
dat <- gnet_met_data %>% filter(WBIC==1842400)
date_matrix = tibble(Date = seq(from=min(dat$Date),to=max(dat$Date),by="day"))
dat <- date_matrix %>% left_join(dat)
dat <- dat %>% mutate(Evap = replace_na(Evap, median(Evap,na.rm=TRUE) )) %>%
mutate(Precip = replace_na(Precip, median(Precip,na.rm=TRUE) ))
met_summary <- dat %>% mutate(year=year(Date)) %>%
dplyr:::select(year,Evap,Precip) %>%
group_by(year) %>%
summarise_all(funs(sum))
ggplot(data= met_summary) + geom_line(aes(x=year,y=Precip)) + geom_line(aes(x=year,y=Evap))
trials = 100
out_loop <- foreach(icount(trials), .combine=cbind) %dopar% {
S = matrix(nrow = nrow(dat),ncol = 1)
S[1,] = 100*1000
for(z in 2:nrow(S)){
sims <- sample_n(gnet_mu_sims,1)
S[z,1] <- S[(z-1),1] + sims[[1,2]]*(dat$Precip[z] + dat$Evap[z]) - (0.000024*S[(z-1),1] + sims[[1,1]])
} #end of time series loop
S
plot(dat$Date,S[,1]/1000,type="l")
} #end 1000 simulation loop
out <- as.data.frame(t(apply(out_loop, 1, quantile, c(0.025,0.5,0.975))))
out <- cbind(dat$WBIC,dat$Date,out)
names(out) <- c("WBIC","Date","ll_val","median_val","ul_val")
} #end lake loop
trials = 100
View(dat)
S = matrix(nrow = nrow(dat),ncol = 1)
S[1,] = 100*1000
z=1
-0.00027966207*S[(z-1),1]
S[(z-1),1]
S[1,] = 100*1000
S[(z-1),1]
S = matrix(nrow = nrow(dat),ncol = 1)
S[1,] = 100*1000
z=2
S[(z-1),1]
-0.00027966207*S[(z-1),1]
100*1000
-0.000027966207*S[(z-1),1]
(-0.000027966207*S[(z-1),1] + sims[[1,1]])
sims <- sample_n(gnet_mu_sims,1)
(-0.000027966207*S[(z-1),1] + sims[[1,1]])
(-0.000027966207*S[(z-1),1] - sims[[1,1]])
sims[[1,1]]
for(z in 2:nrow(S)){
sims <- sample_n(gnet_mu_sims,1)
S[z,1] <- S[(z-1),1] + sims[[1,2]]*(dat$Precip[z] + dat$Evap[z]) - (-0.000027966207*S[(z-1),1] - sims[[1,1]])
} #end of time series loop
plot(dat$Date,S[,1]/1000,type="l")
(-0.000027966207*S[(z-1),1] - sims[[1,1]])
# Lake Level Project Bayesian Hierarchical Model
# Description: This program takes the lake level data and cumulative deviation of
# precipitation data. It runs the Bayesian Hierarchical Model of lake level (response) and
# precipitation (predictor).
##################################################
rm(list=ls())
library(tidyverse)
library(jagsUI)
library(lattice)
library(MCMCpack)
library(arm)
# Input data
dt = read_csv("GW_Models/lake_climate_20180414_openWaterSeason.csv")
dat <- dt %>% dplyr::select(WiscID,WBIC,Date1,DeltaDate,Stage1_mm,Stage2_mm,DeltaWaterLevel_mm,
Precip_mm,Evap_mm) %>% drop_na() %>% arrange(WiscID,Date1) %>%
mutate(PE_mmd = (Precip_mm+Evap_mm)/DeltaDate) %>%
mutate(deltaS_mmd=DeltaWaterLevel_mm/DeltaDate) %>%
mutate(missing = PE_mmd - deltaS_mmd) %>%
filter(missing < 5) %>%
filter(missing > -5)
dat_stage <- dat %>% dplyr:::select(WiscID,Stage1_mm) %>%
group_by(WiscID) %>%
summarise(min_stage = min(Stage1_mm))
dat <- dat %>% left_join(dat_stage) %>%
mutate (uniform_stage = (Stage1_mm-min_stage)+98500)
#Filter the data so that we have at least 5 obs for each lake
(num.rec = table(dat$WBIC))
keep.rec = as.numeric(names((num.rec[which(num.rec>=10)])))
dat = dat[which(dat$WBIC %in% keep.rec),] %>% arrange(WBIC,Date1)
length(unique(dat$WBIC))
ggplot(data = dat, aes(x=PE_mmd,y=deltaS_mmd)) + geom_point() + facet_wrap(vars(WBIC),scales = "free") +
geom_abline(slope = 1,intercept = 0)
####Look at the data
str(dat)
summary(dat)
# Reassign a WiscID to all lakes
# This is not the WiscID used in the big dataset!!!
# Because the jags methods requires a consecutive ID list starting from 1
allLakeList = unique(dat$WBIC)
dat$BHMID = NA
for (i in 1:length(allLakeList)) {
dat$BHMID[dat$WBIC %in% allLakeList[i]] = i
}
dat
# The Model
sink("Model.txt")
cat("
model {
for (i in 1:n){
y[i] ~ dnorm (y.hat[i], tau.y)
y.hat[i] <- alpha[group[i]] + beta[group[i]] * x[i]
}
tau.y <- pow(sigma.y, -2)
sigma.y ~ dunif (0, 10)
nu <- nuMinusOne + 1
nuMinusOne ~ dexp( 1/29 )
# Level-2 of the model
for(j in 1:J){
alpha[j] <- BB[j,1]
beta[j] <- BB[j,2]
BB[j,1:K] ~ dmnorm (BB.hat[j,], Tau.B[,])
BB.hat[j,1] <- mu.a
BB.hat[j,2] <- mu.b
}
mu.a ~ dnorm(-1.1,0.0001)
mu.b ~ dnorm(1,0.0001)
# Model variance-covariance
Tau.B[1:K,1:K] ~ dwish(W[,], df)
df <- K+1
Sigma.B[1:K,1:K] <- inverse(Tau.B[,])
for (k in 1:K){
for (k.prime in 1:K){
rho.B[k,k.prime] <- Sigma.B[k,k.prime]/sqrt(Sigma.B[k,k]*Sigma.B[k.prime,k.prime])
}
sigma.B[k] <- sqrt(Sigma.B[k,k])
}
}
",fill=TRUE)
sink()
# Set up the parameters before run the model
# Number of parameters
K = 2
W <- diag(K)
# Number of lakes
J = length(unique(dat$BHMID))
# Load data raw water level data
dat = as.data.frame(dat)
data = list(y =dat$deltaS_mmd, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
x = dat$PE_mmd, K = K, W = W)
# Initial values
r <- cor(data$x,data$y)
inits <- function (){
list (BB=array(c(rep(rnorm(1,-1.1,1),J),rep(rnorm(1,1,1),J)), c(J,K)),
mu.a=rnorm(1,-1,1),mu.b=rnorm(1,1,1),
sigma.y=runif(1,0,10),
Tau.B=rwish(K+1,diag(K))	 )
}
params1 <- c("BB","mu.a","mu.b", "sigma.y","sigma.B","rho.B")
# Parameters monitored
# mu.alpha: global alpha
# mu.beta: global beta
# BB: local alphas and betas
# sigma: local error term
# sigma.a: variances of alpha
# sigma.b: variances of beta
# rho: covarainces of alpha and beta
#
# MCMC settings
ni <- 7000
nb <- 2000
nc <- 5
nt <- 1
nadp <- 10000
# Run the model
out <- jags(data, inits, params1, "Model.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb,n.adapt = nadp,parallel = TRUE)
BugsOut <- out$summary
#Residual Model
lake_params <- data.frame(WBIC = allLakeList, intercept=BugsOut[1:J,1],slope=BugsOut[(J+1):(J*2),1])
dat <- dat %>% left_join(lake_params) %>%
mutate(residual_val = deltaS_mmd -(PE_mmd*slope + intercept))
plot(dat$uniform_stage,dat$residual_val)
.0002*100000
# The Model
sink("Model.txt")
cat("
model {
for (i in 1:n){
y[i] ~ dnorm (y.hat[i], tau.y)
y.hat[i] <- alpha[group[i]] + beta[group[i]] * x[i]
}
tau.y <- pow(sigma.y, -2)
sigma.y ~ dunif (0, 10)
nu <- nuMinusOne + 1
nuMinusOne ~ dexp( 1/29 )
# Level-2 of the model
for(j in 1:J){
alpha[j] <- BB[j,1]
beta[j] <- BB[j,2]
BB[j,1:K] ~ dmnorm (BB.hat[j,], Tau.B[,])
BB.hat[j,1] <- mu.a
BB.hat[j,2] <- mu.b
}
mu.a ~ dnorm(0,0.0001)
mu.b ~ dnorm(0,0.0001)
# Model variance-covariance
Tau.B[1:K,1:K] ~ dwish(W[,], df)
df <- K+1
Sigma.B[1:K,1:K] <- inverse(Tau.B[,])
for (k in 1:K){
for (k.prime in 1:K){
rho.B[k,k.prime] <- Sigma.B[k,k.prime]/sqrt(Sigma.B[k,k]*Sigma.B[k.prime,k.prime])
}
sigma.B[k] <- sqrt(Sigma.B[k,k])
}
}
",fill=TRUE)
sink()
# Set up the parameters before run the model
# Number of parameters
K = 2
W <- diag(K)
# Number of lakes
J = length(unique(dat$BHMID))
# Load data raw water level data
dat = as.data.frame(dat)
data = list(y =dat$residual_val, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
x = dat$uniform_stage, K = K, W = W)
# Initial values
r <- cor(data$x,data$y)
inits <- function (){
list (BB=array(c(rep(rnorm(1,0,1),J),rep(rnorm(1,0,1),J)), c(J,K)),
mu.a=rnorm(1,0,1),mu.b=rnorm(1,0,1),
sigma.y=runif(1,0,10),
Tau.B=rwish(K+1,diag(K))	 )
}
params1 <- c("BB","mu.a","mu.b", "sigma.y","sigma.B","rho.B")
# Parameters monitored
# mu.alpha: global alpha
# mu.beta: global beta
# BB: local alphas and betas
# sigma: local error term
# sigma.a: variances of alpha
# sigma.b: variances of beta
# rho: covarainces of alpha and beta
#
# MCMC settings
ni <- 7000
# Parameters monitored
# mu.alpha: global alpha
# mu.beta: global beta
# BB: local alphas and betas
# sigma: local error term
# sigma.a: variances of alpha
# sigma.b: variances of beta
# rho: covarainces of alpha and beta
#
# MCMC settings
ni <- 10000
nb <- 5000
nc <- 5
nt <- 1
nadp <- 30000
# Run the model
out2 <- jags(data, inits, params1, "Model.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb,n.adapt = nadp,parallel = TRUE)
(BugsOut2 <- out2$summary)[1:nrow(BugsOut2),]
BugsOut2[99:100,]
mean(dat$uniform_stage)
scale(dat$uniform_stage,scale = F)[1]
dat$uniform_stage[1]
dat$uniform_stage[1]-mean(dat$uniform_stage)
data = list(y =dat$residual_val, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
x = scale(dat$uniform_stage,scale = F), K = K, W = W)
# Initial values
r <- cor(data$x,data$y)
inits <- function (){
list (BB=array(c(rep(rnorm(1,0,1),J),rep(rnorm(1,0,1),J)), c(J,K)),
mu.a=rnorm(1,0,1),mu.b=rnorm(1,0,1),
sigma.y=runif(1,0,10),
Tau.B=rwish(K+1,diag(K))	 )
}
params1 <- c("BB","mu.a","mu.b", "sigma.y","sigma.B","rho.B")
# Parameters monitored
# mu.alpha: global alpha
# mu.beta: global beta
# BB: local alphas and betas
# sigma: local error term
# sigma.a: variances of alpha
# sigma.b: variances of beta
# rho: covarainces of alpha and beta
#
# MCMC settings
ni <- 10000
nb <- 5000
nc <- 5
nt <- 1
nadp <- 30000
# Run the model
out2 <- jags(data, inits, params1, "Model.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb,n.adapt = nadp,parallel = TRUE)
(BugsOut2 <- out2$summary)[1:nrow(BugsOut2),]
BugsOut2[99:100,]
library(tidyverse)
library(lubridate)
library(foreach)
library(doParallel)
library(iterators)
registerDoParallel(cores = 7)
# ####The Data
# Gnet_slopes <- read_csv("data/Gnet_slopes.csv") %>% select(WBIC)
#
# #limit the evap and precip data to the 50 lakes we have GW recharge estimates
# evap_daily <- read_csv("big_data/evap_daily.csv",
#                        col_types = cols(X1 = col_skip())) %>%
#   distinct(WBIC, Date,.keep_all = TRUE) %>% right_join(Gnet_slopes)
# precip_daily <- read_csv("big_data/precip_daily.csv",
#                          col_types = cols(X1 = col_skip())) %>%
#   distinct(WBIC, Date,.keep_all = TRUE) %>% right_join(Gnet_slopes)
#
# dat <- evap_daily %>% full_join(precip_daily)
# write_tsv(dat,"big_data/gnet_met_data.csv")
gnet_met_data <- read_delim("big_data/gnet_met_data.csv",
"\t", escape_double = FALSE, trim_ws = TRUE)
gnet_mu_sims <- read_csv("data/gnet_mu_sims.csv")
#simmulations
lakes = unique(gnet_met_data$WBIC)
for(i in 1:length(lakes)) {
dat <- gnet_met_data %>% filter(WBIC==1842400)
date_matrix = tibble(Date = seq(from=min(dat$Date),to=max(dat$Date),by="day"))
dat <- date_matrix %>% left_join(dat)
dat <- dat %>% mutate(Evap = replace_na(Evap, median(Evap,na.rm=TRUE) )) %>%
mutate(Precip = replace_na(Precip, median(Precip,na.rm=TRUE) ))
met_summary <- dat %>% mutate(year=year(Date)) %>%
dplyr:::select(year,Evap,Precip) %>%
group_by(year) %>%
summarise_all(funs(sum))
ggplot(data= met_summary) + geom_line(aes(x=year,y=Precip)) + geom_line(aes(x=year,y=Evap))
trials = 100
S = matrix(nrow = nrow(dat),ncol = 1)
S[1,] = 100*1000
sims <- sample_n(gnet_mu_sims,1)
lakes = unique(gnet_met_data$WBIC)
dat <- gnet_met_data %>% filter(WBIC==1842400)
date_matrix = tibble(Date = seq(from=min(dat$Date),to=max(dat$Date),by="day"))
dat <- date_matrix %>% left_join(dat)
dat <- dat %>% mutate(Evap = replace_na(Evap, median(Evap,na.rm=TRUE) )) %>%
mutate(Precip = replace_na(Precip, median(Precip,na.rm=TRUE) ))
met_summary <- dat %>% mutate(year=year(Date)) %>%
dplyr:::select(year,Evap,Precip) %>%
group_by(year) %>%
summarise_all(funs(sum))
ggplot(data= met_summary) + geom_line(aes(x=year,y=Precip)) + geom_line(aes(x=year,y=Evap))
trials = 100
S = matrix(nrow = nrow(dat),ncol = 1)
S[1,] = 100*1000
z=2
S[1,]
-9.100742e-1
(-9.100742e-5*(S[(z-1),1]-99276.71) -0.100459 + sims[[1,1]])
sims <- sample_n(gnet_mu_sims,1)
(-9.100742e-5*(S[(z-1),1]-99276.71) -0.100459 + sims[[1,1]])
sims[[1,1]]
(S[(z-1),1]-99276.71)
-9.100742e-5*(S[(z-1),1]-99276.71) -0.100459
for(z in 2:nrow(S)){
sims <- sample_n(gnet_mu_sims,1)
S[z,1] <- S[(z-1),1] + sims[[1,2]]*(dat$Precip[z] + dat$Evap[z]) - (-9.100742e-5*(S[(z-1),1]-99276.71) -0.100459 + sims[[1,1]])
} #end of time series loop
plot(dat$Date,S[,1]/1000,type="l")
for(z in 2:nrow(S)){
sims <- sample_n(gnet_mu_sims,1)
S[z,1] <- S[(z-1),1] + sims[[1,2]]*(dat$Precip[z] + dat$Evap[z]) + (-9.100742e-5*(S[(z-1),1]-99276.71) -0.100459 + sims[[1,1]])
} #end of time series loop
plot(dat$Date,S[,1]/1000,type="l")
-9.100742e-5*(90000-99276.71) -0.100459
-9.100742e-5*(98000-99276.71) -0.100459
(-9.100742e-5*(S[(z-1),1]-99276.71) -0.100459 + sims[[1,1]])
sims[[1,1]]
for(z in 2:nrow(S)){
sims <- sample_n(gnet_mu_sims,1)
S[z,1] <- S[(z-1),1] + sims[[1,2]]*(dat$Precip[z] + dat$Evap[z]) + (-9.100742e-4*(S[(z-1),1]-99276.71) -0.100459 + sims[[1,1]])
} #end of time series loop
plot(dat$Date,S[,1]/1000,type="l")
for(z in 2:nrow(S)){
sims <- sample_n(gnet_mu_sims,1)
S[z,1] <- S[(z-1),1] + sims[[1,2]]*(dat$Precip[z] + dat$Evap[z]) + (-9.100742e-4*(S[(z-1),1]-99276.71) + sims[[1,1]])
} #end of time series loop
plot(dat$Date,S[,1]/1000,type="l")
(-9.100742e-5*(S[(z-1),1]-99276.71) + sims[[1,1]])
sims[[1,1]]
for(z in 2:nrow(S)){
sims <- sample_n(gnet_mu_sims,1)
S[z,1] <- S[(z-1),1] + sims[[1,2]]*(dat$Precip[z] + dat$Evap[z]) + (-9.100742e-5*(S[(z-1),1]-99276.71) + sims[[1,1]])
} #end of time series loop
plot(dat$Date,S[,1]/1000,type="l")
library(readr)
seepage_20180414 <- read_csv("big_data/seepage_20180414.csv")
View(seepage_20180414)
