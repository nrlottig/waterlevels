View(regressionstats)
View(dat2)
rbPal <- colorRampPalette(c('red','blue'))
dat2$Col <- rbPal(20)[as.numeric(cut(dat2$slope,breaks = 20))]
map.regions = c('wisconsin')
par(mar=c(5.1,4.1,4.1,2.1))
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5, main="Water Level Clusters")
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5, main="Water Level Clusters")
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = dat2$slope)
legend.col <- function(col, lev){
opar <- par
n <- length(col)
bx <- par("usr")
box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
box.cy <- c(bx[3], bx[3])
box.sy <- (bx[4] - bx[3]) / n
xx <- rep(box.cx, each = 2)
par(xpd = TRUE)
for(i in 1:n){
yy <- c(box.cy[1] + (box.sy * (i - 1)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i - 1)))
polygon(xx, yy, col = col[i], border = col[i])
}
par(new = TRUE)
plot(0, 0, type = "n",
ylim = c(min(lev), max(lev)),
yaxt = "n", ylab = "",
xaxt = "n", xlab = "",
frame.plot = FALSE)
axis(side = 4, las = 2, tick = FALSE, line = .25)
par <- opar
}
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = dat2$slope)
View(regressionstats)
summary(date2)
summary(dat2)
?cut
?quantile
quantile(dat2$slope,probs=seq(0,1,.25)
quantile(dat2$slope,probs=seq(0,1,.25))
quantile(dat2$slope,probs=seq(0,1,.05))
dat2$Col <- rbPal(20)[as.numeric(cut(dat2$slope,breaks = quantile(dat2$slope,probs=seq(0,1,.05))))]
par(mar=c(5.1,4.1,4.1,2.1))
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = dat2$slope)
dat2$Col <- rbPal(20)[as.numeric(cut(dat2$slope,breaks = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))))]
dat2$Col <- rbPal(20)[as.numeric(cut(dat2$slope,breaks = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05)))))]
dat2$Col
as.numeric(quantile(dat2$slope,probs=seq(0,1,.05)))
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))))
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))))
dat2$Col <- rbPal(10)[as.numeric(cut(dat2$slope,breaks = as.numeric(quantile(dat2$slope,probs=seq(0,1,.115)))))]
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))))
dat2$Col <- rbPal(10)[as.numeric(cut(dat2$slope,breaks = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))))]
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))))
?axis
legend.col <- function(col, lev,lab=TRUE){
opar <- par
n <- length(col)
bx <- par("usr")
box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
box.cy <- c(bx[3], bx[3])
box.sy <- (bx[4] - bx[3]) / n
xx <- rep(box.cx, each = 2)
par(xpd = TRUE)
for(i in 1:n){
yy <- c(box.cy[1] + (box.sy * (i - 1)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i - 1)))
polygon(xx, yy, col = col[i], border = col[i])
}
par(new = TRUE)
plot(0, 0, type = "n",
ylim = c(min(lev), max(lev)),
yaxt = "n", ylab = "",
xaxt = "n", xlab = "",
frame.plot = FALSE)
axis(side = 4, las = 2, tick = FALSE, line = .25,labels=lab)
par <- opar
}
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))))
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))),lab=as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))))
legend.col <- function(col, lev,lab=TRUE){
opar <- par
n <- length(col)
bx <- par("usr")
box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
box.cy <- c(bx[3], bx[3])
box.sy <- (bx[4] - bx[3]) / n
xx <- rep(box.cx, each = 2)
par(xpd = TRUE)
for(i in 1:n){
yy <- c(box.cy[1] + (box.sy * (i - 1)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i - 1)))
polygon(xx, yy, col = col[i], border = col[i])
}
par(new = TRUE)
plot(0, 0, type = "n",
ylim = c(min(lev), max(lev)),
yaxt = "n", ylab = "",
xaxt = "n", xlab = "",
frame.plot = FALSE)
axis(side = 4, las = 2, tick = FALSE, line = .25,labels=lab,at=c(1:10))
par <- opar
}
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))),lab=as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))))
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))),lab=as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))))
as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))
dat2$Col <- rbPal(11)[as.numeric(cut(dat2$slope,breaks = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))))]
legend.col <- function(col, lev,lab=TRUE){
opar <- par
n <- length(col)
bx <- par("usr")
box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
box.cy <- c(bx[3], bx[3])
box.sy <- (bx[4] - bx[3]) / n
xx <- rep(box.cx, each = 2)
par(xpd = TRUE)
for(i in 1:n){
yy <- c(box.cy[1] + (box.sy * (i - 1)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i - 1)))
polygon(xx, yy, col = col[i], border = col[i])
}
par(new = TRUE)
plot(0, 0, type = "n",
ylim = c(min(lev), max(lev)),
yaxt = "n", ylab = "",
xaxt = "n", xlab = "",
frame.plot = FALSE)
axis(side = 4, las = 2, tick = FALSE, line = .25,labels=lab,at=c(1:11))
par <- opar
}
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.05))),lab=as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))))
legend.col <- function(col, lev,lab=TRUE){
opar <- par
n <- length(col)
bx <- par("usr")
box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
box.cy <- c(bx[3], bx[3])
box.sy <- (bx[4] - bx[3]) / n
xx <- rep(box.cx, each = 2)
par(xpd = TRUE)
for(i in 1:n){
yy <- c(box.cy[1] + (box.sy * (i - 1)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i - 1)))
polygon(xx, yy, col = col[i], border = col[i])
}
par(new = TRUE)
plot(0, 0, type = "n",
ylim = c(min(lev), max(lev)),
yaxt = "n", ylab = "",
xaxt = "n", xlab = "",
frame.plot = FALSE)
axis(side = 4, las = 2, tick = FALSE, line = .25)
par <- opar
}
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))))
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = dat2$Col[order(dat2$slope)], lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))))
as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))
as.numeric(cut(dat2$slope,breaks = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))))
legend.val <-rbPal(11)[as.numeric(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))))]
legend.val <-rbPal(11)[as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))]
as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))
legend.val <-rbPal(11)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))))
as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))
as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))
?axis
g
legend.col <- function(col, lev,lab=TRUE,at=NULL){
opar <- par
n <- length(col)
bx <- par("usr")
box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
box.cy <- c(bx[3], bx[3])
box.sy <- (bx[4] - bx[3]) / n
xx <- rep(box.cx, each = 2)
par(xpd = TRUE)
for(i in 1:n){
yy <- c(box.cy[1] + (box.sy * (i - 1)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i - 1)))
polygon(xx, yy, col = col[i], border = col[i])
}
par(new = TRUE)
plot(0, 0, type = "n",
ylim = c(min(lev), max(lev)),
yaxt = "n", ylab = "",
xaxt = "n", xlab = "",
frame.plot = FALSE)
axis(side = 4, las = 2, tick = FALSE, line = .25,lab,at)
par <- opar
}
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),lab=round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2),at=as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))))
round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),lab=round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2))
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),lab=round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2))
legend.val
length(legend.val)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 1:11,lab=round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2),at=1:11)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 1:11,lab=round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2),at=1:11)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=0:10,at=0:10)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=0:10,at=0:10)
legend.lab = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))))
legend.lab = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))
legend.lab
legend.lab = round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2)
legend.lab
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
legend.col <- function(col, lev,lab=TRUE,at=NULL){
opar <- par
n <- length(col)
bx <- par("usr")
box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
box.cy <- c(bx[3], bx[3])
box.sy <- (bx[4] - bx[3]) / n
xx <- rep(box.cx, each = 2)
par(xpd = TRUE)
for(i in 1:n){
yy <- c(box.cy[1] + (box.sy * (i - 1)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i - 1)))
polygon(xx, yy, col = col[i], border = col[i])
}
par(new = TRUE)
plot(0, 0, type = "n",
ylim = c(min(lev), max(lev)),
yaxt = "n", ylab = "",
xaxt = "n", xlab = "",
frame.plot = FALSE)
axis(side = 4, las = 2, tick = FALSE, line = .25,labels=lab,at=at)
par <- opar
}
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
rbPal <- colorRampPalette(c('red','green','blue'))
dat2$Col <- rbPal(11)[as.numeric(cut(dat2$slope,breaks = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))))]
legend.val <-rbPal(11)
legend.lab = round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
rbPal <- colorRampPalette(c('red','green','blue','orange'))
dat2$Col <- rbPal(11)[as.numeric(cut(dat2$slope,breaks = as.numeric(quantile(dat2$slope,probs=seq(0,1,.1)))))]
legend.val <-rbPal(11)
legend.lab = round(as.numeric(quantile(dat2$slope,probs=seq(0,1,.1))),2)
map.regions = c('wisconsin')
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5)
points(dat2$long,dat2$lat,col=alpha(dat2$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
out$BUGSoutput$mean$mu.alpha
out$BUGSoutput$mean$mu.beta
global.slope = as.numeric(quantile(out$BUGSoutput$sims.list$mu.beta,c(0.025,0.975)))
library(readr)
anvillake <- read_csv("anvillake.csv")
View(anvillake)
plot(anvillake$date,anvillake$obs_waterlevel_mm,type="b",col=alpha(1,.7),pch=16,cex=.8)
graphics.off()
plot(anvillake$date,anvillake$obs_waterlevel_mm,type="b",col=alpha(1,.7),pch=16,cex=.8)
plot(anvillake$date,anvillake$obs_waterlevel_mm,type="b",col=alpha(1,.7),pch=16,cex=.8,xlab="Date",ylab="Water Level (mm)")
lines(anvillake$date,anvillake$modeled_waterlevel_mm,type="b",col=alpha(2,.7),pch=16,cex=.8,)
points(anvillake$date,anvillake$modeled_waterlevel_mm,type="b",col=alpha(2,.7),pch=16,cex=.8,)
points(anvillake$date,anvillake$modeled_waterlevel_mm,type="b",col=alpha(2,.7),pch=16,cex=.8)
points(anvillake$date,anvillake$modeled_waterlevel_mm,type="b",col=alpha(3,.7),pch=16,cex=.8)
points(anvillake$date,anvillake$modeled_waterlevel_mm,type="b",col=alpha(4,.7),pch=16,cex=.8)
plot(anvillake$date,anvillake$obs_waterlevel_mm,type="b",col=alpha(1,.7),pch=16,cex=1,xlab="Date",ylab="Water Level (mm)")
points(anvillake$date,anvillake$modeled_waterlevel_mm,type="b",col=alpha(4,.7),pch=16,cex=1)
legend("topright",legend=c("Observed","Modeled"),col=c(alpha(1,.7),alpha(4,.7)),pch=16,lty=1,cex=0.8)
plot(anvillake$date,anvillake$obs_waterlevel_mm,type="b",col=alpha(1,.7),pch=16,cex=1,xlab="Date",ylab="Water Level (mm)",main="Anvil Lake")
points(anvillake$date,anvillake$modeled_waterlevel_mm,type="b",col=alpha(4,.7),pch=16,cex=1)
legend("topright",legend=c("Observed","Modeled"),col=c(alpha(1,.7),alpha(4,.7)),pch=16,lty=1,cex=0.8)
plot(anvillake$date,anvillake$obs_waterlevel_mm,type="b",col=alpha(1,.7),pch=16,cex=1,xlab="Date",ylab="Water Level (mm)",main="Anvil Lake")
points(anvillake$date,anvillake$modeled_waterlevel_mm,type="b",col=alpha(4,.7),pch=16,cex=1)
legend("topright",legend=c("Observed","Modeled"),col=c(alpha(1,.7),alpha(4,.7)),pch=16,lty=1,cex=0.8)
rbPal <- colorRampPalette(c('red','green','blue'))
dt = read_csv("GW_Models/HLM_out.csv")
EcoContext <- read_excel("RFModels/EcoContext.xlsx")
dat = dt %>% left_join(select(EcoContext,WiscID,lat,long)) %>% drop_na()
dat$Col <- rbPal(11)[as.numeric(cut(dat$Gnet,breaks = as.numeric(quantile(dat$Gnet,probs=seq(0,1,.1)))))]
legend.val <-rbPal(11)
legend.lab = round(as.numeric(quantile(dat$Gnet,probs=seq(0,1,.1))),2)
map.regions = c('wisconsin')
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5, main="Water Level Clusters")
par(mar=c(5.1,4.1,4.1,2.1))
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5, main="Water Level Clusters")
points(dat$long,dat$lat,col=alpha(dat$Col,1),pch=16)
legend.col <- function(col, lev,lab=TRUE,at=NULL){
opar <- par
n <- length(col)
bx <- par("usr")
box.cx <- c(bx[2] + (bx[2] - bx[1]) / 1000,
bx[2] + (bx[2] - bx[1]) / 1000 + (bx[2] - bx[1]) / 50)
box.cy <- c(bx[3], bx[3])
box.sy <- (bx[4] - bx[3]) / n
xx <- rep(box.cx, each = 2)
par(xpd = TRUE)
for(i in 1:n){
yy <- c(box.cy[1] + (box.sy * (i - 1)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i)),
box.cy[1] + (box.sy * (i - 1)))
polygon(xx, yy, col = col[i], border = col[i])
}
par(new = TRUE)
plot(0, 0, type = "n",
ylim = c(min(lev), max(lev)),
yaxt = "n", ylab = "",
xaxt = "n", xlab = "",
frame.plot = FALSE)
axis(side = 4, las = 2, tick = FALSE, line = .25,labels=lab,at=at)
par <- opar
}
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
graphics.off()
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5, main="Water Level Clusters")
points(dat$long,dat$lat,col=alpha(dat$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
rbPal <- colorRampPalette(c('red','green','blue','orange'))
dat$Col <- rbPal(11)[as.numeric(cut(dat$Gnet,breaks = as.numeric(quantile(dat$Gnet,probs=seq(0,1,.1)))))]
legend.val <-rbPal(11)
legend.lab = round(as.numeric(quantile(dat$Gnet,probs=seq(0,1,.1))),2)
map('state',region=map.regions,col=grey(.98),fill=TRUE,resolution = 0,mar=c(0,0,0,0),border=grey(.5),lty=5, main="Water Level Clusters")
points(dat$long,dat$lat,col=alpha(dat$Col,1),pch=16)
# legend("topright",legend=c("Gnet -2.70 mm/d","Gnet 0.150 mm/d"),pch=16,col=c("#FF0000","#0000FF"),title = "Net Groundwater Discharge",bty="n")
legend.col(col = legend.val, lev = 0:10,lab=legend.lab,at=0:10)
# Lake Level Project Bayesian Hierarchical Model
# Description: This program takes the lake level data and cumulative deviation of
# precipitation data. It runs the Bayesian Hierarchical Model of lake level (response) and
# precipitation (predictor).
##################################################
rm(list=ls())
library(tidyverse)
library(R2jags)
library(lattice)
# Input data
dt = read_csv("GW_Models/lake_climate_20180414_openWaterSeason.csv")
dat = dt %>% select(WiscID,Date1,DeltaDate,Stage1_mm,Stage2_mm,DeltaWaterLevel_mm,
Precip_mm,Evap_mm) %>% drop_na() %>% arrange(WiscID,Date1) %>%
mutate(PE_mmd = (Precip_mm+Evap_mm)/DeltaDate) %>%
mutate(deltaS_mmd=DeltaWaterLevel_mm/DeltaDate)
#Filter the data so that we have at least 5 obs for each lake
num.rec = table(dat$WiscID)
keep.rec = as.numeric(names((num.rec[which(num.rec>=2)])))
dat = dat[which(dat$WiscID %in% keep.rec),]
####Look at the data
str(dat)
summary(dat)
# Reassign a WiscID to all lakes
# This is not the WiscID used in the big dataset!!!
# Because the jags methods requires a consecutive ID list starting from 1
allLakeList = unique(dat$WiscID)
dat$BHMID = NA
for (i in 1:length(allLakeList)) {
dat$BHMID[dat$WiscID %in% allLakeList[i]] = i
}
# The Model
sink("model.txt")
cat("
model {
# Likelihood:
# Level-1 of the model
for (i in 1:n){
y[i] ~ dt(mu[i], tau, tdf)
mu[i] <- alpha[group[i]] + beta[group[i]] * precip[i]
}
# Level-2 of the model
for(j in 1:J){
alpha[j] <- BB[j,1]
beta[j] <- BB[j,2]
BB[j,1:K] ~ dmnorm(BB.hat[j,], Tau.B[,]) # bivriate normal
BB.hat[j,1] <- mu.alpha
BB.hat[j,2] <- mu.beta
}
# Priors and derived quantities
sigma ~ dunif(0, 100)
tau <- pow(sigma,-2) # precision
udf ~ dunif(0,1)
tdf <- 1 - tdfGain *log(1-udf)
sigma2 <- pow(sigma,2)
mu.alpha ~ dnorm(0, 0.0001)
mu.beta ~ dnorm(0, 0.0001)
# Convert covariance matrix to precision for use in bivariate normal above
Tau.B[1:K,1:K] <- inverse(Sigma.B[,])
# variance among intercepts
Sigma.B[1,1] <- pow(sigma.a, 2)
sigma.a ~ dunif (0, 100)
# Variance among slopes
Sigma.B[2,2] <- pow(sigma.b, 2)
sigma.b ~ dunif (0, 100)
# Covariance between alpha's and beta's
Sigma.B[1,2] <- rho * sigma.a * sigma.b
Sigma.B[2,1] <- Sigma.B[1,2]
# Uniform prior on correlation
rho ~ dunif (-1, 1)
} # end model
",fill = TRUE)
sink()
# Set up the parameters before run the model
# Number of parameters
K = 2
# Number of lakes
J = length(unique(dat$BHMID))
# Load data raw water level data
tdfGain = 1
dat = as.data.frame(dat)
data = list(y = dat$deltaS_mmd, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
precip = dat$PE_mmd, K = K,tdfGain = tdfGain)
# Initial values
inits = function (){
list(mu.alpha = rnorm(1), mu.beta=rnorm(1), sigma=runif(1),
BB=matrix(rnorm(J*K),nrow=J,ncol=K), sigma.a=runif(1), sigma.b=runif(1), rho=runif(1),
udf = 0.95)
}
# Parameters monitored
# mu.alpha: global alpha
# mu.beta: global beta
# BB: local alphas and betas
# sigma: local error term
# sigma.a: variances of alpha
# sigma.b: variances of beta
# rho: covarainces of alpha and beta
#
parameters = c("mu.alpha","mu.beta","BB","sigma", "sigma.a", "sigma.b","rho")
# MCMC settings
ni <- 20000
nb <- 10000
nc <- 3
(nt <- ceiling((ni-nb)*nc/500))
# Run the model
out = jags.parallel(data, inits, parameters, "model.txt", n.chains = 3,
n.thin = 60, n.iter = 20000, n.burnin = 60)
str(out)
global.slope = as.numeric(quantile(out$BUGSoutput$sims.list$mu.alpha,c(0.025,0.975)))
global.slope
