names(model.data)[Y.col]
#,sampsize=rep(min(table(Y)),nlevels(Y)),strata=Y
(rf.data = randomForest(y = Y,x = X,keep.inbag=TRUE,importance=TRUE,ntree=10001))
libdat = EcoContext %>% left_join(regressionstats) %>% select(-ID,-OBJECTID,-WATERBODY_NAME,-HYDROID,-HYDROCODE,
-HYDROTYPE,-LANDLOCK_C,-WBIC,-SHAPE_AREA,-SHAPE_LEN,
-County,-MeanDepth,-problem,-hydro24k,-centroid_x,
-centroid_y,-NATURAL_COMMUNITY,-Lake_type,-HYDROLOGY,
-`Katie classification`,-`Katie notes`) %>% drop_na()
View(libdat)
dat = EcoContext %>% left_join(regressionstats) %>% select(-ID,-OBJECTID,-WATERBODY_NAME,-HYDROID,-HYDROCODE,
-HYDROTYPE,-LANDLOCK_C,-WBIC,-SHAPE_AREA,-SHAPE_LEN,
-County,-MeanDepth,-problem,-hydro24k,-centroid_x,
-centroid_y,-NATURAL_COMMUNITY,-Lake_type,-HYDROLOGY,
-`Katie classification`,-`Katie notes`) %>% drop_na()
dat = dat %>% select(-W_BD_201,-W_BD_204,-W_BD_205,-W_BD_206,-W_BD_207,-W_BD_208,-W_BD_209,-W_BD_210,-W_BD_MISSI,
-W_BR_2,-W_BR_3,-W_BR_MISSI,-W_QG_3,-W_QG_4,-W_QG_6,-W_QG_7,-W_QG_8,-W_QG_9,-W_QG_10,
-W_QG_11,-W_QG_12,-W_QG_13,-W_QG_14,-W_QG_15,-W_QG_16,-W_QG_17,-W_QG_18,-W_QG_20,
-W_QG_21,-W_QG_22,-W_QG_24,-W_QG_29,-W_QG_99,-W_QG_MISSI,-W_LU06_23,-W_LU06_24,-W_LU06_31)
dat = dat %>% select(everything(),-contains("LU11"))
summary(dat)
dat = dat %>% mutate(W_LA_Ratio = WatershedA/Area)
model.data = dat #choose which dataset to use so code works without editing further down
names(model.data)
#set response variable
Y.col = 40
Y = model.data[[Y.col]]
names(model.data)[Y.col]
X = model.data[,c(2:37)]
names(X)
X = model.data[,c(2:37,41)]
names(X)
#,sampsize=rep(min(table(Y)),nlevels(Y)),strata=Y
(rf.data = randomForest(y = Y,x = X,keep.inbag=TRUE,importance=TRUE,ntree=10001))
#set response variable
Y.col = 39
Y = model.data[[Y.col]]
names(model.data)[Y.col]
#,sampsize=rep(min(table(Y)),nlevels(Y)),strata=Y
(rf.data = randomForest(y = Y,x = X,keep.inbag=TRUE,importance=TRUE,ntree=10001))
summary(regressionstats$Gnet)
-1.75*365/10
-1.45*365/10
global.slope = as.numeric(quantile(out$BUGSoutput$sims.list$mu.alpha,c(0.025,0.975)))
sapply(out$BUGSoutput$sims.list$BB[1:4500,1:466,2],function(x) quantile(x,c(0.025,0.975)))
str(out)
global.slope = as.numeric(quantile(out$BUGSoutput$sims.list$mu.beta,c(0.025,0.975)))
sapply(out$BUGSoutput$sims.list$BB[1:1500,1:51,1],function(x) quantile(x,c(0.025,0.975)))
sims.out = as.data.frame(out$BUGSoutput$sims.list$BB[1:1500,1:51,1])
lakeinterval = as.data.frame(t(sapply(sims.out,function(x) quantile(x,c(0.025,0.975)))))
lake.interval = Intervals(t(sapply(sims.out,function(x) quantile(x,c(0.025,0.975)))))
over.lap = interval_overlap(from = lake.interval,to = global.slope)
over.lap = as.numeric(sapply(over.lap,'[',1))
library(intervals)
lake.interval = Intervals(t(sapply(sims.out,function(x) quantile(x,c(0.025,0.975)))))
over.lap = interval_overlap(from = lake.interval,to = global.slope)
over.lap = as.numeric(sapply(over.lap,'[',1))
over.lap
lake.interval
slope.class = rep(NA,51)
for(i in 1:nrow(lakeinterval)){
if (lakeinterval[i,2] < global.slope[1]) slope.class[i] = 0 else if(lakeinterval[i,1] > global.slope[2]) slope.class[i]=2 else slope.class[i] =1
}
slope.class
global.slope
global.slope = as.numeric(quantile(out$BUGSoutput$sims.list$mu.beta,c(0.025,0.975)))
global.slope
out
str(out)
global.slope = as.numeric(quantile(out$BUGSoutput$sims.list$mu.alpha,c(0.025,0.975)))
slope.class = rep(NA,51)
for(i in 1:nrow(lakeinterval)){
if (lakeinterval[i,2] < global.slope[1]) slope.class[i] = 0 else if(lakeinterval[i,1] > global.slope[2]) slope.class[i]=2 else slope.class[i] =1
}
slope.class
table(slope.class)
lake.interval
global.slope
View(regressionstats)
regressionstats$gnet.class = slope.class
View(regressionstats)
install.packages("BayesianFirstAid")
install.packages("BayesianFirstAid")
install.packages("BEST")
library(BEST)
y1 = out$BUGSoutput$sims.list$mu.alpha
y2 =out$BUGSoutput$sims.list$BB[1:1500,7,1]
BESTout = BESTmcmc(y1,y2)
plot(BESTout)
graphics.off()
plot(BESTout)
mean(y1)
mean(y2)
hist(y1-y2)
plot(BESTout)
mean(y1-y2)
y2 =out$BUGSoutput$sims.list$BB[1:1500,1,1]
BESTout = BESTmcmc(y1,y2)
plot(BESTout)
mean(y1-y2)
hist(y1-y2)
# Lake Level Project Bayesian Hierarchical Model
# Description: This program takes the lake level data and cumulative deviation of
# precipitation data. It runs the Bayesian Hierarchical Model of lake level (response) and
# precipitation (predictor).
##################################################
rm(list=ls())
# Set WD
# setwd("G:/CFL/R_workdirectary")
library(tidyverse)
library(R2jags)
library(lattice)  # plot
library(lubridate)
library(MLmetrics)
# Input data
dat = read_tsv("BayHModels/BHM_input_20180410.csv")
# Reassign a WiscID to all lakes
# This is not the WiscID used in the big dataset!!!
# Because the jags methods requires a consecutive ID list starting from 1
allLakeList = unique(dat$WiscID)
dat$BHMID = NA
for (i in 1:length(allLakeList)) {
dat$BHMID[dat$WiscID %in% allLakeList[i]] = i
}
#standardize the lowest observed water level to 1000mm (1m)
lakes = unique(dat$BHMID)
for(i in 1:length(lakes)){
temp = dat$Value[dat$BHMID %in% lakes[i]]
std.level = temp-min(temp)+1000
dat$Value[dat$BHMID %in% lakes[i]] = std.level
}
#standardize the lowest observed precipCMDV to 0
for(i in 1:length(lakes)){
temp = dat$precipCMDV[dat$BHMID %in% lakes[i]]
std.level = temp-min(temp)
dat$precipCMDV[dat$BHMID %in% lakes[i]] = std.level
}
summary(dat)
# The Model
sink("model.txt")
cat("
model {
# Likelihood:
# Level-1 of the model
for (i in 1:n){
y[i] ~ dnorm(mu[i], tau)
mu[i] <- alpha[group[i]] + beta[group[i]] * precip[i]
}
# Level-2 of the model
for(j in 1:J){
alpha[j] <- BB[j,1]
beta[j] <- BB[j,2]
BB[j,1:K] ~ dmnorm(BB.hat[j,], Tau.B[,]) # bivriate normal
BB.hat[j,1] <- mu.alpha
BB.hat[j,2] <- mu.beta
}
# Priors and derived quantities
sigma ~ dunif(0, 100)
tau <- pow(sigma,-2) # precision
sigma2 <- pow(sigma,2)
mu.alpha ~ dnorm(0, 0.0001)
mu.beta ~ dnorm(0, 0.0001)
# Convert covariance matrix to precision for use in bivariate normal above
Tau.B[1:K,1:K] <- inverse(Sigma.B[,])
# variance among intercepts
Sigma.B[1,1] <- pow(sigma.a, 2)
sigma.a ~ dunif (0, 100)
# Variance among slopes
Sigma.B[2,2] <- pow(sigma.b, 2)
sigma.b ~ dunif (0, 100)
# Covariance between alpha's and beta's
Sigma.B[1,2] <- rho * sigma.a * sigma.b
Sigma.B[2,1] <- Sigma.B[1,2]
# Uniform prior on correlation
rho ~ dunif (-1, 1)
#predicted lake levels
for (i in 1:n){
yp[i] ~ dnorm(alpha[group[i]] + beta[group[i]] * precip[i], tau)
}
} # end model
",fill = TRUE)
sink()
# Set up the parameters before run the model
# Number of parameters
K = 2
# Number of lakes
J = length(unique(dat$BHMID))
# Load data raw water level data
dat = as.data.frame(dat)
data = list(y = dat$Value, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
precip = dat$precipCMDV, K = K)
# Initial values
inits = function (){
list(mu.alpha = rnorm(1), mu.beta=rnorm(1), sigma=runif(1),
BB=matrix(rnorm(J*K),nrow=J,ncol=K), sigma.a=runif(1), sigma.b=runif(1), rho=runif(1) )
}
# Parameters monitored
# mu.alpha: global alpha
# mu.beta: global beta
# BB: local alphas and betas
# sigma: local error term
# sigma.a: variances of alpha
# sigma.b: variances of beta
# rho: covarainces of alpha and beta
#
parameters = c("mu.alpha","mu.beta","BB","sigma", "sigma.a", "sigma.b","rho","yp")
# MCMC settings
ni <- 50000
nt <- 20
nb <- 20000
nc <- 3
# Run the model
out = jags.parallel(data = data,
inits = inits,
parameters.to.save = parameters,
model.file = "model.txt",
n.chains = 3,
n.thin = 20,
n.iter = 50000,
n.burnin = 20000,
n.cluster = 3)
str(out)
nrow(dat)
# out.mcmc <- as.mcmc(out)
# str(out.mcmc)
# require(lattice)
# look at summary
# summary(out.mcmc)
# # Create traceplots
# xyplot(out.mcmc)
# Look at posterior density plots
# densityplot(out.mcmc)
pred_sims = out$BUGSoutput$sims.list$yp
# out.mcmc <- as.mcmc(out)
# str(out.mcmc)
# require(lattice)
# look at summary
# summary(out.mcmc)
# # Create traceplots
# xyplot(out.mcmc)
# Look at posterior density plots
# densityplot(out.mcmc)
pred_sims = as.data.frame(out$BUGSoutput$sims.list$yp)
View(pred_sims)
?t()
# out.mcmc <- as.mcmc(out)
# str(out.mcmc)
# require(lattice)
# look at summary
# summary(out.mcmc)
# # Create traceplots
# xyplot(out.mcmc)
# Look at posterior density plots
# densityplot(out.mcmc)
pred_sims = as.data.frame(t(out$BUGSoutput$sims.list$yp))
pred_sims = cbind(dat$WiscID,pred_sims)
# out.mcmc <- as.mcmc(out)
# str(out.mcmc)
# require(lattice)
# look at summary
# summary(out.mcmc)
# # Create traceplots
# xyplot(out.mcmc)
# Look at posterior density plots
# densityplot(out.mcmc)
pred_sims = as.data.frame(t(out$BUGSoutput$sims.list$yp))
pred_sims = cbind(dat$WiscID,dat$Date,pred_sims)
# out.mcmc <- as.mcmc(out)
# str(out.mcmc)
# require(lattice)
# look at summary
# summary(out.mcmc)
# # Create traceplots
# xyplot(out.mcmc)
# Look at posterior density plots
# densityplot(out.mcmc)
pred_sims = as.data.frame(t(out$BUGSoutput$sims.list$yp))
pred_sims = cbind(dat$WiscID,dat$Date,,dat$Value,pred_sims)
pred_sims = cbind(dat$WiscID,dat$Date,dat$Value,pred_sims)
pred_sims$mean = apply(dat[,3:4503],mean())
pred_sims$mean = apply(dat[,3:4503],FUN=mean())
pred_sims$mean = apply(dat[,3:4503],FUN=mean(x))
pred_sims$mean = apply(dat[,3:4503],FUN=mean)
pred_sims$mean = apply(dat[,3:4503],1,FUN=mean)
mean.val = apply(dat[,3:4503],1,FUN=mean)
mean.val = apply(dat[,c(3:4503)],1,FUN=mean)
dat[,c(3:4503)]
mean.val = apply(pred_sims[,c(4:4503)],1,FUN=mean)
mean.val
pred_sims$mean = apply(pred_sims[,c(4:4503)],1,FUN=mean)
?quantile
pred_sims$ll = apply(pred_sims[,c(4:4503)],1,FUN=quantile(probs=0.025))
pred_sims$ll = apply(pred_sims[,c(4:4503)],1,FUN=function(x) quantile(probs=0.025))
pred_sims$ll = apply(pred_sims[,c(4:4503)],1,FUN=function(x) quantile(x,probs=0.025))
pred_sims$ul = apply(pred_sims[,c(4:4503)],1,FUN=function(x) quantile(x,probs=0.975))
test = pred_sims %>% select(everything(),-contains("V"))
View(test)
names(pred_sims)[3] ="observed"
names(pred_sims)[3] ="obs"
pred_sims = pred_sims %>% select(everything(),-contains("V"))
View(pred_sims)
names(pred_sims)[1:3] =c("WiscID","Date","obs")
pred_sims$Date = as.character(dat$Date)
pred_sims$Date = paste(dat$Date,"/15",sep="")
pred_sims$Date = as_date(x = dat$Date)
# out.mcmc <- as.mcmc(out)
# str(out.mcmc)
# require(lattice)
# look at summary
# summary(out.mcmc)
# # Create traceplots
# xyplot(out.mcmc)
# Look at posterior density plots
# densityplot(out.mcmc)
pred_sims = as.data.frame(t(out$BUGSoutput$sims.list$yp))
pred_sims = cbind(dat$WiscID,dat$Date,dat$Value,pred_sims)
names(pred_sims)[1:3] =c("WiscID","Date","obs")
pred_sims$mean = apply(pred_sims[,c(4:4503)],1,FUN=mean)
pred_sims$ll = apply(pred_sims[,c(4:4503)],1,FUN=function(x) quantile(x,probs=0.025))
pred_sims$ul = apply(pred_sims[,c(4:4503)],1,FUN=function(x) quantile(x,probs=0.975))
pred_sims = pred_sims %>% select(everything(),-contains("V"))
pred_sims$Date = as.character(dat$Date)
pred_sims$Date = paste(dat$Date,"/15",sep="")
pred_sims$Date = as_date(x = pred_sims$Date)
dt = pred_sims %>% filter(WiscID==371)
plot(dt$Date,dt$obs)
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="thistle",border=NA)
lines(dt$mean,pch=16,type="b",col="blue")
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
plot(dt$Date,dt$obs)
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="thistle",border=NA)
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
plot(dt$obs,dt$mean)
abline(a=0,b=1)
dt = pred_sims %>% filter(WiscID==48)
plot(dt$Date,dt$obs)
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="thistle",border=NA)
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="thistle",border=NA)
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="thistle",border=NA)
lines(dt$Date,dt$obs,pch=16,col="black",type="b")
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="b")
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
dt = pred_sims %>% filter(WiscID==132)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="b")
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
dt = pred_sims %>% filter(WiscID==132) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="b")
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
dt = pred_sims %>% filter(WiscID==205) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="b")
lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="b")
dt = pred_sims %>% filter(WiscID==215) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="b")
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="l")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
dt = pred_sims %>% filter(WiscID==444) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
dt = pred_sims %>% filter(WiscID==539) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
dt = pred_sims %>% filter(WiscID==562) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
dt = pred_sims %>% filter(WiscID==584) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
dt = pred_sims %>% filter(WiscID==593) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
dt = pred_sims %>% filter(WiscID==819) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
# lines(dt$Date,dt$mean,pch=16,type="b",col="blue")
dt = pred_sims %>% filter(WiscID==1030) %>% arrange(Date)
plot(dt$Date,dt$obs,ylim=range(dt$ll,dt$ul))
polygon(c(dt$Date,rev(dt$Date)),c(dt$ll,rev(dt$ul)),col="grey",border="darkgrey")
lines(dt$Date,dt$obs,pch=16,col="black",type="p")
View(dat)
# Lake Level Project Bayesian Hierarchical Model
# Description: This program takes the lake level data and cumulative deviation of
# precipitation data. It runs the Bayesian Hierarchical Model of lake level (response) and
# precipitation (predictor).
##################################################
rm(list=ls())
library(tidyverse)
library(jagsUI)
library(lattice)
library(MCMCpack)
library(arm)
# Input data
dt = read_csv("GW_Models/lake_climate_20180414_openWaterSeason.csv")
dat <- dt %>% dplyr::select(WiscID,Date1,DeltaDate,Stage1_mm,Stage2_mm,DeltaWaterLevel_mm,
Precip_mm,Evap_mm) %>% drop_na() %>% arrange(WiscID,Date1) %>%
mutate(PE_mmd = (Precip_mm+Evap_mm)/DeltaDate) %>%
mutate(deltaS_mmd=DeltaWaterLevel_mm/DeltaDate)
#Filter the data so that we have at least 5 obs for each lake
num.rec = table(dat$WiscID)
keep.rec = as.numeric(names((num.rec[which(num.rec>=10)])))
dat = dat[which(dat$WiscID %in% keep.rec),]
length(unique(dat$WiscID))
####Look at the data
str(dat)
summary(dat)
# Reassign a WiscID to all lakes
# This is not the WiscID used in the big dataset!!!
# Because the jags methods requires a consecutive ID list starting from 1
allLakeList = unique(dat$WiscID)
dat$BHMID = NA
for (i in 1:length(allLakeList)) {
dat$BHMID[dat$WiscID %in% allLakeList[i]] = i
}
# The Model
sink("Model.txt")
cat("
model {
for (i in 1:n){
y[i] ~ dnorm (y.hat[i], tau.y)
y.hat[i] <- alpha[group[i]] + beta[group[i]] * x[i]
}
tau.y <- pow(sigma.y, -2)
sigma.y ~ dunif (0, 10)
# Level-2 of the model
for(j in 1:J){
alpha[j] <- BB[j,1]
beta[j] <- BB[j,2]
BB[j,1:K] ~ dmnorm (BB.hat[j,], Tau.B[,])
BB.hat[j,1] <- mu.a
BB.hat[j,2] <- mu.b
}
mu.a ~ dnorm(0,0.0001)
mu.b ~ dnorm(0,0.0001)
# Model variance-covariance
Tau.B[1:K,1:K] ~ dwish(W[,], df)
df <- K+1
Sigma.B[1:K,1:K] <- inverse(Tau.B[,])
for (k in 1:K){
for (k.prime in 1:K){
rho.B[k,k.prime] <- Sigma.B[k,k.prime]/
sqrt(Sigma.B[k,k]*Sigma.B[k.prime,k.prime])
}
sigma.B[k] <- sqrt(Sigma.B[k,k])
}
}
",fill=TRUE)
sink()
# Set up the parameters before run the model
# Number of parameters
K = 2
W <- diag(K)
# Number of lakes
J = length(unique(dat$BHMID))
# Load data raw water level data
dat = as.data.frame(dat)
data = list(y =dat$deltaS_mmd, group = as.numeric(dat$BHMID), n = dim(dat)[1], J = J,
x = dat$PE_mmd, K = K, W = W)
# Initial values
r <- cor(data$x,data$y)
inits <- function (){
list (BB=array(c(rep(rnorm(1,0,1),J),rep(rnorm(1,0,1),J)), c(J,K)),
mu.a=rnorm(1,0,1),mu.b=rnorm(1,0,1),
sigma.y=runif(1,0,10),
Tau.B=rwish(K+1,diag(K))	 )
}
params1 <- c("BB","mu.a","mu.b", "sigma.y","sigma.B","rho.B")
# Parameters monitored
# mu.alpha: global alpha
# mu.beta: global beta
# BB: local alphas and betas
# sigma: local error term
# sigma.a: variances of alpha
# sigma.b: variances of beta
# rho: covarainces of alpha and beta
#
# MCMC settings
ni <- 40000
nb <- 10000
nc <- 3
(nt <- ceiling((ni-nb)*nc/1500))
# Run the model
out <- jags(data, inits, params1, "Model.txt", n.chains = nc,
n.thin = nt, n.iter = ni, n.burnin = nb, parallel = T)
saveRDS(out,"GW_Models/HLM_reduced.rds")
# Summarize posteriors
print(out, dig = 3)
